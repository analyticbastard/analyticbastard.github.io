<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Brainteasers | The Analytic Bastard]]></title>
  <link href="http://analyticbastard.github.io/blog/categories/brainteasers/atom.xml" rel="self"/>
  <link href="http://analyticbastard.github.io/"/>
  <updated>2015-10-13T19:51:17+02:00</updated>
  <id>http://analyticbastard.github.io/</id>
  <author>
    <name><![CDATA[Analytic Bastard]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Max Subsequence Problem]]></title>
    <link href="http://analyticbastard.github.io/blog/2015/05/02/max-subsequence-problem/"/>
    <updated>2015-05-02T21:05:23+02:00</updated>
    <id>http://analyticbastard.github.io/blog/2015/05/02/max-subsequence-problem</id>
    <content type="html"><![CDATA[<p>The following brainteaser is about finding the maximum-sum subsequence within a given sequence.
We will solve this problem in Clojure, sice this will involve less pain than doing it in Java.</p>

<p>We need to decompose the sequence in parts, and a natural way of doing it is dividing it in halves,
using a binary tree. For this purpose, we take the sequence at the current stage, divide it in two
parts, and call the same function recursively for each half. The recursion-stopping criteria are the point when
we find either two or only one element in the sequence (odd or even super sequence), at which point
we return the information we need (we’ll talk about this later on).</p>

<p>&#8220;` Clojure
(defn best [myseq]
  (let [N (count myseq)]
    (case N
      1 nil
      2 nil
      (let [n (Math/round (double (/ N 2)))
            m (- N n)
            s1 (take n myseq)
            s2 (take-last m myseq)
            m1 (best s1)
            m2 (best s2)
            ]</p>

<pre><code>    ))
)) ``` 
</code></pre>

<p>This was the basic recursion skeleton. Now we need to return and process the interesting information
about the sequence at each stage. We need the maximum-sum sub-sequence at each stage in the binary
search, the discarded sequence at the left, and the discarded sequence at the right (both of which must be
negative because they would otherwise increase the sum). For example, the sequence <code>[-1 -1 3 4 -2]</code> would
produce a best subsequence <code>[3 4]</code>, a discarded left sequence <code>[-1 -1]</code> and a discarded right sequence
[-2]. Optionally and for the sake of performance, we also return the sums of these sequences, so that
we don’t need to recompute at the upper-levels (when returning from the call). The information retrieved from
the lower levels is a map with this structure (using the previous example):</p>

<p>&#8220;` Clojure</p>
<p>&#8220;`</p>

<p>where the first three keys are the sums, and the last three keys are the proper sequences. We now build
the information according to the sequence we recieve as input. When there is only one element, it is easy to
see that we need to return empty discarded sequences, and the input number as the best sequence. If we get
two elements, we need to check whether both are positive, in which case, we return both as the best sequence
(and empty discarded left and right sequences). Otherwise, get the maximum, return it as the best sequence,
and return the other as either the left or right discarded sequence depending on whether it was the first or
second in the sequence. Note, at this point, that the discarded sequences mean how large the penalization is
to get to the best sequence for a given subsequence from the left or the right. In the recursion stage, when
we have two subsequences, we need to check if the total sum of both best subsequences and everything in the
middle (the right discarded sequence from the left half and the left discarded sequence from the right half)
is larger than the maximum of the best subsequence of either half. We concatenate the sequences to compose
the left and right discarded sequences, and the best sequences up to this stage. This is the result:</p>

<p><code>Clojure
(defn best [myseq]
  (let [N (count myseq)]
    (case N
      1 {:l 0 :r 0 :sl [] :sr [] :seq myseq :sum (first myseq)}
      2 (if (and (&gt; (first myseq) 0) (&gt; (second myseq) 0))
          {:l 0 :r 0 :sl [] :seq myseq :sr [] :sum (apply + myseq)}
          (if (&lt; (first myseq) (second myseq))
            {:l (first myseq) :r 0 :sl [(first myseq)] :sr [] :seq (rest myseq) :sum (second myseq)}
            {:l 0 :r (second myseq) :sl [] :sr (rest myseq) :seq [(first myseq)] :sum (first myseq)}))
      (let [n (Math/round (double (/ N 2)))
            m (- N n)
            s1 (take n myseq)
            s2 (reverse (take m (reverse myseq)))
            m1 (best s1)
            m2 (best s2)
            sum2 (+ (:sum m1) (:sum m2))
            cost (+ (:r m1) (:l m2))
            sumt (+ sum2 cost)
            ]
        (if (&gt; sumt (max (:sum m1) (:sum m2)))
          {:l (:l m1) :r (:r m2) :sl (:sl m1) :sr (:sr m2) :seq (concat (:seq m1) (:sr m1) (:sl m2) (:seq m2)) :sum sumt}
          (if (&gt; (:sum m1) (:sum m2))
            {:l (:l m1) :r (+ (:r m1) (:l m2) (:sum m2) (:r m2)) :sl (:sl m1) :sr (concat (:sr m1) (:sl m2) (:seq m2) (:sr m2)) :seq (:seq m1) :sum (:sum m1)}
            {:l (+ (:l m1) (:r m1) (:sum m1) (:l m2)) :r (:r m2) :sl (concat (:sl m1) (:seq m1) (:sr m1) (:sl m2)) :sr (:sr m2) :seq (:seq m2) :sum (:sum m2)}))
        ))
    ))
</code></p>

<p>As test data, we choose three sequences, one whose best subsequence is in the middle, separated by negative numbers
(one in this case), another whose best subsequence is at the left side, and it is not worth to join it with another
positive sequence at the right side, and one whose best subsequence is itself.</p>

<p><code>Clojure
(def ex-bestmiddle [-1 -3 -2 1 2 -1 3 -2 2 1 -1 -3])
(def ex-bestleft [-1 3 2 1 -2 -5 -3 -3 2 3 -1 -3])
(def ex-bestall [5 -3 -2 2 2 -1 3 -2 2 1 -1 3])
</code></p>

<p>For the last one:</p>

<p><code>Clojure
(best ex-bestall)
</code></p>

<p>&#8220;` Clojure</p>
<p>&#8220;`</p>

<p>For the best subsequence on the left side:</p>

<p><code>Clojure
(best ex-bestleft)
</code></p>

<p>&#8220;` Clojure</p>
<p>&#8220;`</p>

<p>And for the best subsequence in the middle:</p>

<p><code>Clojure
(best ex-bestmiddle)
</code></p>

<p>&#8220;` Clojure</p>
<p>&#8220;`</p>

<p>The code is on <a href="https://github.com/analyticbastard/java-exercises">Github</a> under <code>src/main/clj</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Monty Hall Problem (My Explanation)]]></title>
    <link href="http://analyticbastard.github.io/blog/2015/03/08/the-monty-hall-problem-my-explanation/"/>
    <updated>2015-03-08T00:17:17+01:00</updated>
    <id>http://analyticbastard.github.io/blog/2015/03/08/the-monty-hall-problem-my-explanation</id>
    <content type="html"><![CDATA[<p>If I tell you: There are 1K bitcoins 1 wallet that will be yours if you guess which wallet out of three is the right one, the rest containing an amount of zero bitcoins, and ask you to point out an initial selection, then showed you that, effectively, one of the remaining wallets contains zero bitcoins… and finally giving you the opportunity to change wallet. Would you change? The awnser is yes.</p>

<p>This is so because there is new evidence now that supports a higher probability that the remaining unseen wallet is the right choice, whereas there is none about your current choice. The fact that you selected wallet 1, and given that choice, I showed you wallet 2, that leaves wallet 3 with a posterior probability of 2/3. This does not happen for our current wallet 1, since choosing 1 influenced my decision to show you 2. More precisely: You chose wrongly with probability 2/3. With that probability, I show you the only possible door that I can, leaving the 2/3 for the remaining unseen and unchosen door. On the contrary, you choose well with 1/3 probability, but then I can choose among 2 doors to show you, each with a probability of 1/2. This is how we include my decision (or necessity) to show you 2 into the math (this is the best explanation you are gonna get from all over the internet):
Let’s call R “right choice” V “visible incorrect wallet” and S “your choice”. We need to compute <script type="math/tex">P(R=3|V=2,S=1)</script>, the probability of 3 being the right wallet, after you selected 1 and I showed you that 2 was not right (remember that all priors are 1/3).
<script type="math/tex">P(R=3|V=2,S=1)=\frac{P(V=2,S=1|R=3)P(R=3)}{P(V=2,S=1|R=3)P(R=3)+P(V=2,S=1|R=1)P(R=1)}\\=\frac{1\times 1/3}{1\times 1/3 + 1/2 \times 1/3}=2/3</script><script type="math/tex">P(V=2,S=1|R=3)=1</script> is the probability that, given R=3, then I was forced to show you the incorrect wallet remaining (you already chose one incorrect wallet). <script type="math/tex">P(V=2,S=1|R=1)=1/2</script> because there are two possible incorrect wallets (since you selected the correct one) that I can choose from to show you.</p>

<p>Let’s compute the same posterior for the case I decide not to change wallet:
<script type="math/tex">P(R=1|V=2,S=1)=\frac{P(V=2,S=1|R=1)P(R=1)}{P(V=2,S=1|R=3)P(R=3)+P(V=2,S=1|R=1)P(R=1)}\\=\frac{1/2\times 1/3}{1\times 1/3 + 1/2 \times 1/3}=1/3</script>.</p>

<p>Therefore if you change you have more chances of winning the 1000 bitcoins.</p>

<p>Needless to say, this works for every possible combination of <script type="math/tex">R</script>, <script type="math/tex">S</script> and <script type="math/tex">V</script>. 
This happens, as I mentioned, because of the way I was influenced (forced) to show you the incorrect remaining wallets. To see it intuitively, imagine 100 wallets, and that you chose one amongst them, and I am forced to show you 98 incorrect wallets, leaving your choice and another one. Is it more likely that this particular wallet is the correct one (that your choice forced me to leave it) or that you chose wisely amongst 100 wallets? If you choose 99 incorrect wallets, the set that I show you is the same, except for the chosen incorrect wallets each time, and will never contain the particular correct wallet.</p>

<p>There is a cool <a href="https://play.google.com/store/apps/details?id=us.steveo.montyhall">Android app</a> in case you want to check how the law of large numbers works for this problem.</p>
]]></content>
  </entry>
  
</feed>
