<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Image Processing | The Analytic Bastard]]></title>
  <link href="http://analyticbastard.github.io/blog/categories/image-processing/atom.xml" rel="self"/>
  <link href="http://analyticbastard.github.io/"/>
  <updated>2015-03-09T14:54:28+01:00</updated>
  <id>http://analyticbastard.github.io/</id>
  <author>
    <name><![CDATA[Analytic Bastard]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Image Pan-sharpening With PCA]]></title>
    <link href="http://analyticbastard.github.io/blog/2015/02/20/image-pan-sharpening-with-pca/"/>
    <updated>2015-02-20T11:27:48+01:00</updated>
    <id>http://analyticbastard.github.io/blog/2015/02/20/image-pan-sharpening-with-pca</id>
    <content type="html"><![CDATA[<p>There is a collection of methods that are denominated image pan-sharpening, since they use
information available in multiple bands to create an image output that enjoys properties
from all sources, while minimizing drawbacks. The sources combined will contain several
frequency bands, maybe hundreds or thousands. In this case, we are interested in combining
a source with a high resolution but in gray scale, and a RGB image.</p>

<p>This is especially important in satellite imagery, since satellites often incorporate
a multispectral camera with limited resolution and a high-resolution, low-band/grayscale
camera among their equipment.</p>

<p>To play with this, we will use Matlab (since I’ve worked a little bit with its image
functions and array transformations, and this job will be quick)</p>

<p>We first load original image (included in Matlab)</p>

<p><code>matlab
peppers = imread('peppers.png');
</code></p>

<p><img class="center" src="/images/peppers.png" title="‘Original image’ ‘images’" ></p>

<p>Now we simulate uniband (grayscale) and multiband (downscaled) imagery</p>

<p><code>matlab
multiband = imresize(peppers, 0.25);
uniband = rgb2gray(peppers);
</code></p>

<p>The multiband image looks like this</p>

<p><img class="center" src="/images/multiband.png" title="‘Multiband image’ ‘images’" ></p>

<p>And the high resolution (low band) image looks like this</p>

<p><img class="center" src="/images/uniband.png" title="‘High resolution image’ ‘images’" ></p>

<p>In the first case, we resize the image to a quarter of its size <strong><em>in both dimensions</em></strong>.
This means we loose 15/16 of the information! In the second case we compute a grayscale
image, loosing complementary information.</p>

<p>These two images are the ones we are interested in combining.</p>

<p>We now upscale multiband image (again, color image and same size than original but with
the information from the downscaled version)</p>

<p><code>matlab
interpolated=imresize(multiband,[size(uniband,1) size(uniband,2)]);
</code></p>

<p>We will now perform PCA on the images. To do that we need to convert the images to the
relevant variables we want to consider in the analysis. In this case, we want to extract
the bands of the images, so that we linearize the images, thus turning matrices into
unidimensional vectors. In case of the grayscale image, this is easily done by just
using the <code>(:)</code> operator. Bit in case of the RGB image, we will need to
reshape into a three-dimensional multivariate X = (R, G, B)</p>

<p><code>matlab
X=double(reshape(interpolated,numel(interpolated)/3,3));
</code></p>

<p>where we have also converted the data type to double so that we can use Matlab functions.</p>

<p>Now we can compute the components and the projections onto the PCA space</p>

<p><code>matlab
[C,Y]=pca(X);
</code></p>

<p>where <code>C</code> is the matrix of loadings and <code>Y</code> is the projections of the data onto
the PCA space.</p>

<p>At this point, out of curiosity, we can compute correlations. Notice that the first
projection will correlate a lot with the univariate, since both capture mean luminosity
levels, which is an indicator of which component can be substituted by the higher
resolution grayscale image.</p>

<p><code>matlab
corrcoef(Y(:,1),double(uniband(:)))
corrcoef(Y(:,2),double(uniband(:)))
corrcoef(Y(:,3),double(uniband(:)))
</code></p>

<p>The first one yields around <code>0.98</code>. Substitute the component now</p>

<p><code>matlab
Z=Y;
Z(:,1)=(double(uniband(:)-min(uniband(:)))./double(max(uniband(:))-min(uniband(:))))*(max(Y(:,1))-min(Y(:,1)))+min(Y(:,1));
</code></p>

<p>We are adapting the maximum and minimum luminosity of the grayscale image to match
that of the first component.</p>

<p>We now project the new components back to the original RGB space. The matrix <code>C</code> is not
orthonormal, so that we don’t get a properly scaled representation, so we do it manually
(we could also make the matrix <code>C</code> orthonormal, though the effect of changing the first
component would have impacted the final luminosity levels and thus we still would have needed
to rescale the colors)</p>

<p><code>matlab
G=Z*C';
I = (G - min(G(:)))/(max(G(:))-min(G(:)));
</code></p>

<p>Lastly we reshape from (R, G, B) multivariate to an RGB image</p>

<p><code>matlab
merged = reshape(I, size(interpolated));
</code></p>

<p>The result shows that, effectively, we enjoy the best part of the two worlds</p>

<p><img class="center" src="/images/merged.png" title="‘Merged image’ ‘images’" ></p>

<p>As mentioned, we could play with the luminiscence levels to attain a color more loyal
to the original.</p>

<p>The reason why this works is that the first PCA component takes most of the information,
thus creating a sort of best fit for all colors in the RGB spectrum. This is a kind of
luminiscence, which is what the grayscape image is and what we substitute it by.</p>
]]></content>
  </entry>
  
</feed>
